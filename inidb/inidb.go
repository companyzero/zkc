// Copyright (c) 2016 Company 0, LLC.
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

// inidb package uses a regular ini file as a database.  Ini sections are
// considered tables.  Individual  entries are considered records and are
// key = value pairs.
//
// The package assumes that the user will create a single inidb per directory.
package inidb

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"sync"
	"time"

	"github.com/marcopeereboom/lockfile"
	"github.com/vaughan0/go-ini"
)

const (
	auto = "# This file is autogenerated, DO NOT EDIT!"
	// LockDuration is the default timeout for database locks
	LockDuration = 5 * time.Second
)

var (
	ErrCouldNotLock = errors.New("could not lock")
	ErrNotFound     = errors.New("record not found")
	ErrCreated      = errors.New("database created")
)

// INIDB is an opaque structure that contains the database context.
type INIDB struct {
	mtx      sync.Mutex         // mutex for this structure
	filename string             // inidb full path
	depth    int                // max journal files that are kept
	dirty    bool               // like your mom
	created  bool               // db was created
	lock     *lockfile.LockFile // filesystem lock
	timeout  time.Duration      // lock timeout
	tables   ini.File           // ini sections
}

// New returns a new INIDB context.  Depth contains the maximum number of files
// that are retained.  Create indicates if the database should be created if it
// doesn't exist. If depth is negative there is no limit.  If the ini file does
// not exist it returns an error.
// The inidb package assumes there is only one inidb per directory.  DO NOT
// CREATE MULTIPLE INIDBS IN A SINGLE DIRECTORY.
func New(filename string, create bool, depth int) (*INIDB, error) {
	i := INIDB{
		filename: filename,
		depth:    depth,
		timeout:  LockDuration,
	}

	//
	// this is a little hokey in order to not be too racy
	//

	var err error
	dirname := path.Join(path.Dir(filename), ".lock")
	i.lock, err = lockfile.New(dirname, time.Second)
	if os.IsNotExist(err) && create {
		err = os.MkdirAll(path.Dir(filename), 0700)
		if err != nil {
			return nil, fmt.Errorf("could not create directory: %v",
				err)
		}

		// and make sure we have a lock structure
		i.lock, err = lockfile.New(dirname, time.Second)
		if err != nil {
			return nil, err
		}

	} else if err != nil {
		return nil, fmt.Errorf("could not create lock %v: %v",
			path.Dir(filename), err)
	}

	// obtain lock before opening db
	err = i.Lock()
	if err != nil {
		return nil, ErrCouldNotLock
	}

	i.tables, err = ini.LoadFile(filename)
	i.tables.Section("") // default always exists
	if os.IsNotExist(err) && create {
		// save empty file
		i.created = true
		i.dirty = true
		err2 := i.Save()
		if err2 != nil {
			i.Unlock() // not much error recovery we can do
			return nil, err2
		}

		err = ErrCreated // indicate we just created it
	} else if err != nil {
		i.Unlock() // not much error recovery we can do
		return nil, fmt.Errorf("could not open %v: %v", filename, err)
	}

	// unlock database
	err2 := i.Unlock()
	if err2 != nil {
		return nil, err2
	}

	return &i, err
}

// LockTimeout sets the timeout furation of database locks.
func (i *INIDB) LockTimeout(t time.Duration) {
	i.timeout = t
}

// Lock locks the database by creating a lock file in the same directory as the
// database files.
func (i *INIDB) Lock() error {
	return i.lock.Lock(i.timeout)
}

// Unlock unlocks the database by removing the lock file in the same directory
// as the database files.
func (i *INIDB) Unlock() error {
	return i.lock.Unlock()
}

// Save flushes current in memory database back to disk.  The process is as
// follows:
//	1. Check if the database is dirty and abort process if it isn't
//	2. Create temporary file that contains all memory tables and records
//	3. Backup original file
//	4. Rename temporary file to the original file name
// This creates a running log of flushes.
//
// NOTE: currently there is no file count limiter.
func (i *INIDB) Save() error {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	if !i.dirty {
		return nil
	}

	f, err := ioutil.TempFile(path.Dir(i.filename), path.Base(i.filename))
	if err != nil {
		return fmt.Errorf("could not create temporary file: %v", err)
	}

	// save all records
	fmt.Fprintf(f, "%v\n", auto)
	for tk, tv := range i.tables {
		if tk != "" {
			fmt.Fprintf(f, "[%v]\n", tk)
		}
		for rk, rv := range tv {
			fmt.Fprintf(f, "%v = %v\n", rk, rv)
		}
		fmt.Fprintf(f, "\n")
	}
	f.Close()

	// backup original
	if !i.created {
		backup := fmt.Sprintf("%v.%v",
			i.filename,
			time.Now().Format("20060102.150405.000000000"))
		err = os.Rename(i.filename, backup)
		if err != nil {
			return fmt.Errorf("could not rename original file: %v",
				err)
		}
	}

	// rename new one
	err = os.Rename(f.Name(), i.filename)
	if err != nil {
		return fmt.Errorf("could not rename new file: %v", err)
	}

	i.dirty = false

	return i.prune()
}

func (i *INIDB) prune() error {
	if i.depth < 0 {
		return nil
	}

	d, err := ioutil.ReadDir(path.Dir(i.filename))
	if err != nil {
		return fmt.Errorf("could not read directory %v: %v",
			path.Dir(i.filename), err)
	}

	// create prune list
	pl := make([]string, 0, len(d))
	find := path.Base(i.filename) + "."
	for _, v := range d {
		if !strings.HasPrefix(v.Name(), find) {
			continue
		}
		pl = append(pl, v.Name())
	}

	// actually prune
	if len(pl)-i.depth < 0 {
		return nil
	}

	for _, v := range pl[:len(pl)-i.depth] {
		_ = os.Remove(path.Join(path.Dir(i.filename), v))
	}

	return nil
}

// Get returns a record from table.  If the record does not exist ErrNotFound
// is returned.
func (i *INIDB) Get(table string, key string) (string, error) {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	value, ok := i.tables.Get(table, key)
	if !ok {
		return "", ErrNotFound
	}

	return value, nil
}

// Set creates/overwrites a record in table.  If table does not exist
// ErrNotFound is returned.
func (i *INIDB) Set(table, key, value string) error {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	s, ok := i.tables[table]
	if !ok {
		return ErrNotFound
	}
	s[key] = value
	i.dirty = true

	return nil
}

// Del remove a record from a table.
func (i *INIDB) Del(table, key string) error {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	s, ok := i.tables[table]
	if !ok {
		return ErrNotFound
	}

	delete(s, key)
	i.dirty = true

	return nil
}

// NewTable creates a new table.
func (i *INIDB) NewTable(table string) {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	i.tables.Section(table)
}

// DelTable deletes an entire table including all records.
func (i *INIDB) DelTable(table string) error {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	_, ok := i.tables[table]
	if !ok {
		return ErrNotFound
	}

	delete(i.tables, table)
	i.dirty = true

	return nil
}

// Records returns a copy of all records in the given table.
func (i *INIDB) Records(table string) map[string]string {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	t := make(map[string]string)
	for k, v := range i.tables[table] {
		t[k] = v
	}

	return t
}

// Tables returns a copy of all tables in the inidb.
func (i *INIDB) Tables() []string {
	i.mtx.Lock()
	defer i.mtx.Unlock()

	tables := make([]string, 0, len(i.tables))

	for k := range i.tables {
		tables = append(tables, k)
	}

	return tables
}
